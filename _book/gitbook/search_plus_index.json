{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction TradeLayer Protocol Documentation Welcome to the official documentation for the TradeLayer protocol. This documentation covers everything from protocol mechanics, API usage, fees, and trade execution mechanics. It is designed to help developers, traders, and users understand how TradeLayer works and how to integrate with the protocol. What is TradeLayer? TradeLayer is a decentralized protocol for trading and creating synthetic assets on top of blockchain networks. It enables trustless peer-to-peer trading, derivatives, and token issuance using the security and decentralization of Proof of Work chains like Bitcoin, Litecoin and Dogecoin. "},"introduction/OVERVIEW.html":{"url":"introduction/OVERVIEW.html","title":"Overview","keywords":"","body":"📋 ###Overview TradeLayer is a decentralized exchange protocol based on old-school cypherpunk principles of modular decentralization with: no central points of capture built for Bitcoin, Litecoin and Dogecoin featuring trading of: spot UTXO-for-token token-for-token Perpetual swaps Futures (Coming soon) Options Minting and redemption of derivatives-backed synthetic currency Per-collateral cross-margin Lightning-style co-signing of trades for lowest-latency performance Own your market structure. Download the desktop wallet to get started: Start Trading Last updated: [1072024] "},"introduction/VISION.html":{"url":"introduction/VISION.html","title":"Vision","keywords":"","body":"Vision Run the wallet on an airgap computer, never connected to the internet, and build transactions in the multisig editor, commit tokens to the Layer 2 for an address on your internet-connected computer.Then run the wallet on your connected machine and route funds to channels rapidly for fast execution.Most DEx protocols require using an insecure browser-extension wallet and having trading and custody managed by the same key, this is not appropriate for large sums of money or institutional capital. Every DEx has components of: Consensus Logic Trade Execution Deposit/Withdrawal Most DEx protocols utilize their own app chain or a bridged rollup and a centralized smart contract address to process trading logic, usually on a Proof-of-Stake blockchain. For speed, most DEx protocols rely on a centralized off-chain sequencer run by the project team to rapidly process trades. Most DEx protocols rely on centralized stablecoins as the main source of liquidity and deposit/withdrawal of these tokens into the smart contract acts as a black box. TradeLayer replaces these with: **OP_Return tokens** parsed on a Proof of Work blockchain.Anyone can run a full node and verify state, and refer the rules of parsing OP_Return data to a historical hash of the code base. **Multisig channels**, it’s possible to achieve even lower latencies by re-using a channel and further by co-locating with counterparties.Most-inefficient execution (6 pings across continents) takes about 1.5 seconds, distant channel re-use takes ~1 second, regional counterparties shaves another half second, co-location can bring latencies under 100ms, with further optimizations this could be brought to 10-20ms.**Anyone can run an orderbook** and route capital to any channel. **Decentralized Collateral** - to get around the programmability limitations of UTXO money like BTC, LTC and Doge it’s possible to atomically trade for tokens, paying the token-seller in the same transaction as the OP_Return guarantees delivery of the tokens to the UTXO spender.These transactions form on-chain data that removes the need for oracles, settling native perpetual swaps.The native perps then enable minting of synthetic BTC, LTC and Doge.Chain abstraction enables smart contracts that govern transaction signing to automate market making of e.g.LTC for synthetic LTC.This enables a decentralize on/off-ramp for funds in and out of TradeLayer. It’s also possible and probably important to have liquid centralized stablecoins and oracle-based derivatives on TradeLayer, these create a liquidity backstop and alternative revenue flow for the decentralized stablecoin system. It’s very common for DEx documentation to nest the fee information in its own page but here we’re going to end each page with a reminder that the fees are 0.5 basis points total.If you keep co-signing unpublished trades with a counterparty in a channel and then erase them by signing a PNL update transaction, you can get that even lower.We’re competing with Wall St.and regulatory exchange fee minimums. Browser-extension trading and other wallet integrations coming in the future. Start Trading Last updated: [1072024] "},"introduction/CROSSCHAIN.html":{"url":"introduction/CROSSCHAIN.html","title":"Cross-Chain","keywords":"","body":"TradeLayer Cross Utilizing the power of Chain Signatures on NEAR, it’s possible to do a number of interesting things with UTXOs and token transactions on TradeLayer, one of these is enabling cross-chain swaps.Because TradeLayer runs off of synced nodes for Proof of Work blockchains, it would be possible to have native cross-chain swaps if running full Bitcoin, Litecoin and Dogecoin nodes were required, because this is prohibitively memory intensive there’s a simpler solution: NEAR smart contracts that bind Send and Transfer transactions on both chains.This enables easy transfer of similar assets between chains. Cross-Chain Swaps A NEAR smart contract participant binds an amount of USDC on NEAR or NEAR native currency, a multisig address is created with a key from the user sending on e.g.Litecoin and a key controlled by the Chain Signatures MPC confederation on NEAR, and the sender’s address on the delivery chain, such as Bitcoin, is submitted to the smart contract.A market maker listens for request-for-quotes from that relayer smart contract and responds by creating a channel on e.g.Bitcoin with the MPC confederation holding the second key.Then the user sends their asset on Litecoin to the channel address, the market maker sends their asset on Bitcoin to the other channel address, and the MPC confederation fulfills their bonded pledge by producing and signing the send transactions to the respective delivery addresses on each chain. It’s possible to do this with Transfer instead of Sends, moving Commited tokens on the L2 between channels across the 3 chains that TradeLayer supports.This makes it possible to have a unified orderbook across all chains and orderbook servers, de-fragmenting liquidity, at a modest routing cost… as long as miner fees are low. While not available at launch the power to route things across the Proof of Work ecosystem is exciting. Cross-chain Bridging Back in 2015 USDT was first issued on the OmniLayer protocol, the ancestor of the TradeLayer protocol, using an administrative address where tokens could be minted and redeemed.Using a similar transaction type, it’s possible to manage centralized stablecoin and security tokens on TradeLayer, but what if this could be somewhat decentralized? Using Chain Signatures it’s possible to build cross-chain bridge contracts from NEAR to Litecoin, Bitcoin and Dogecoin, with the redemption of tokens being taken as a proof to unlock the redemption of bridged tokens on the smart contract chain. While the early stage of TradeLayer’s launch will seek to have native issuance of smaller stablecoin contenders, the bridge application potential means that the wider DeFi galaxy can interact with TradeLayer in the future.To properly have an oracle that can guarantee the redemption of tokens based on valid balances, it will require that the current .js or future Rust implementation of TradeLayer be deployed on NEAR, but it’s a feasible solution when combined with an attestation of code version and tx index state to extrapolate from, with the matching txindex logged on the NEAR DA layer. UTXO AMM Millions have been spent and the best minds in Bitcoin have wept over the challenge of doing more with raw BTC UTXOs without compromising the underlying Bitcoin protocol with a risky new hard fork.BitVM, Stacks and Botanix-like multisig models, ZK proofs of chain headers, Lightning Network virtual private channel factories and nested Taproot DLC contracts have all been tried, but since they’re navigating around a rigid structure they run into contortions, high costs and limited modularity.With Chain abstraction, it’s in theory possible to have TradeLayer’s synthetic model be automated with smart contracts that sign off on trades in an automated-market-maker, keeping a price near 1:1 for LTC to sLTC and so forth.AMMs like Curve that are providing raw liquidity on things like USDT/USDC, taking only credit and liquidity risk in the underlying instruments,the same idea applies for LTC/sLTC or BTC/sBTC market making.The challenge is in bringing the state of TradeLayer token balances to the smart contract environment. Virtualizing PoW Chains in WASM The ZeroSync project shows a promising way of using ZK proofs to verify block headers and getting the last mile with cheaper-to-compute Merkel proofs such as UTreeXO, but the complications of ZK proving Scrypt leave the Chain Signature model on NEAR as an easier way to virtualize chain-state and make TradeLayer provably interactive with smart contracts.NEAR also brings advantages in having a very cost efficient Data Availabilty service and reasonable gas costs. In order to make all of the above possible, the roadmap involves modifying Aurora’s Bitcoin Light Client relayer app for NEAR to Litecoin, integrating that with our wallet, and having relayers collate a tx index on NEAR as decentralized oracle.This approach distributes attack surface but is still subject to Sybil attacks, so ultimately we need to move towards a semi-full node implementation of Litecoin for NEAR, involving smart contract verification of Scrypto proof-of-work.In the mean-time we’ll have a quorum of privileged key-holders attest to the TradeLayer persistence checkpoint that is every 1000 blocks (approximately every 42 hours) to cross-check the distributed light-client submissions of TradeLayer tx.Later when we complete the larger task of virtualizing the recent chain history on NEAR, the process will become fully decentralized and the consensus of Scrypt miners will become binding for verifying transactions reviewed by NEAR smart contracts in considering when to push UTXOs on Litecoin. While baseline protocol fees in TradeLayer are very low, there may be some additional fee routed as UTXO to addresses linked to smart contracts to compensate stakers for running this service and offset the cost of gas in virtualizing contracts.With current Litecoin activity and NEAR prices the cost of fully virtualizing the whole chain would be about $700-800 USD a year, with full blocks and higher NEAR prices the cost could balloon to 15k-50k a year, but the added fee shouldn’t need to be much higher than $1 per transaction as these scale together. Last updated: [1072024] "},"protocol/OP_RETURN_LAYER.html":{"url":"protocol/OP_RETURN_LAYER.html","title":"OP_Return Layer","keywords":"","body":"OP_Return Transactions Every since the Mastercoin and Counterparty protocols launched in 2014, there have been people stuffing data into Bitcoin transactions in order to read them and come up with the state of tokens moving around the chain.While the original design document for Mastercoin (later rebranded as OmniLayer) included bi-lateral derivatives without a clearing system, the feature was never implemented, nor did spot trading despite the issuance of almost a billion USDT on the chain, due to problems with slow block times and high miner fees.The OP_Return field is a catch-all null op_code in the Bitcoin protocol where up to 80 bytes can be reliable stored, relayed by other nodes, and pruned when calculating the UTXO set (which shows who owns how much BTC).Likewise, TradeLayer starts fresh by parsing transactions from a genesis height (much later than the Bitcoin or Litecoin genesis block, defined when the protocol first activates) and logs which OP_Return transactions include a special marker. Tx Index and Consensus The Tx Index accumulates all the possible transactions that might be valid or invalid TradeLayer transactions, and hashes them, which is useful as a foundation for consensus checking.Then the protocol’s core application loops through the tx index in sequence and checks the tx type, there are 36 types of transactions in TradeLayer, fitting neatly within 1 byte in base 36 encoding.Based on the tx type, the payload is decoded and the parameters are checked for validity, for instance sending tokens (tx type 2) requires that the sender address has tokens of propertyId N Run-time If there is no transaction index in the protocol the app will go into tx indexing mode and this can take half an hour or several hours depending on the length of history.Once the tx index is build, or if it’s already built up to some block, then the protocol will loop through to build consensus up to that block, and then enter block-lag mode, where recent transactions will be parsed and indexed, then processed into consensus.Once chain-tip is reached, real-time mode begins, catching new transactions, indexing and processing them.Sequence priority is given to some transactions for logic reasons, if they are in a single block with potentially competing transactions, this is particularly relevant for layer 2 functionality. If there is a data corruption or a re-org, the protocol will fall back to the last persistence checkpoint which are logged very 1000 blocks, and rebuild consensus from that point.If there is an internet outage or the application is otherwise interrupted, it will be able to pick up from the last processed block. How does TradeLayer have such low 0.5 bps fees? It factors out the hosting, compliance and routing costs of exchange operation to running full nodes, decentralized sequencers and whitelists, what’s left is pure software, open-sourced as a tool for humanity. Last updated: [1072024] "},"protocol/TRADE_TYPES.html":{"url":"protocol/TRADE_TYPES.html","title":"Trade Types","keywords":"","body":"Trading Types TradeLayer supports several types of trade transactions: On-chain token for token On-chain contract Channel token-for-token Channel contract UTXO-for token AMM The on-chain trades create an orderbook based on confirmed transactions, this is quite slow and requires an additional transaction to cancel, but it’s useful as a final liquidity backstop.There is an AMM that enables pool of tokens to trade against other tokens or as contract collateral, and provide a buyer-of-last resort for contract liquidations, this is useful as the AMM can update its contribution to the orderbook based on oracle prices or relevant token prices without needing to cancel and replace orders, somewhat improving the problems with a slow on-chain orderbook.To compensate for the risk of data manipulation by wash traders and the general adverse selection risk, the AMM will generally quote wide and broadly with a higher fee going as a rebate to the pool, and will earn half of liquidation fees with the other half going to insurance funds. Channels Channel trading solves the problem of slow trade settlement by creating a way to execute trades quickly.Traders agree on price, make a multisig address, fund it with a Commit or Transfer transaction (one uses Available balance tokens that are freely move-able, the other uses Channel balance tokens that have already been Commit-ed) and then build the trade and co-sign it.This enables trading of tokens or derivatives via OP_Return, involving funding with the relevant token amounts as trade principal or as initial margin, and also enables UTXO-for-token trades to engage securely. Channel trading by default is much faster than on-chain trading, potentially hundreds of times faster, with clear price execution.However compared to the fasted DExes, the default latency involving multiple pings across the world can verge on 1-2 seconds.When trading again with a counterparty, a channel address can be re-used, saving 2 of 5 steps up to the co-sign, this shaves about 30% of the latency.Funds can be pooled between top channels and easily transferred, if there is UTXO available to build a trade tx then transfers don’t need to be published to have an output to build from, they can be briefly held like cheques and published later, this can shave another 30% of the latency. Colocating can further reduce latency.In the future it may be possible to pre-pledge to a trade in a smart contract and holding a tx that can bind stake on that smart contract becomes as good as the subsequent trade, that could enable the most extreme low latency, possibly breaking new records for the industry.The legos are so flexible here, you can have total flexibility and get decent latency for the naked eye, or cluster activity among top counterparties and optimize towards the computational limits of trading algorithms.Best of all, it’s just people signing transactions and publishing them to censorship-resistant proof of work chains, if colocation servers become problematic due to regulatory capture, move servers.Decentralized sequencing is the realization of Satoshi’s Vision, even if he didn’t specifically anticipate it. Last updated: [1072024] "},"protocol/LAYER_2.html":{"url":"protocol/LAYER_2.html","title":"Layer 2","keywords":"","body":"Layer 2 Model The brilliant thing about the Lightning Network is that two signatures on a 2-of-2 multisig becomes an immediately binding consensus lock of a transaction, and that transaction doesn’t need to be published immediately.The limiting factor of the Lightning Network is that the UTXO model, which very memory efficient to track with Merkelization, is a nightmare to route.Account-based tokens can simply be debited from address A and credited to address B with logic, whether a smart contract like on Ethereum or inline logic like in TradeLayer.Combining the two models means you can get fast consensus in a Bitcoin-like environment without relying on slow block confirmation, and it also means routing can be painless. And so, we built Trade Channels.Trade Channels are a Layer 2 model based on the following 4 transaction types: Commit Commiting tokens takes them out of the spendable model that they live in on-chain by default, and puts them into Layer 2 mode.The principle differences follow: Tokens move from the Available column in the tally map to Channel Tokens can be pledged to an address controlled by the user or a 2-of-2 multisig they share with a counterparty Channels are recorded as having commit addresses and columns, A and B, which column a commiter is assigned is deterministic based on the sequence of the last letter of the address or the second to last in case of a tie and the third to last character in case of a rare double-tie. Withdraw Withdraw transactions are issued from the address that originally Committed them to the layer 2 system, pulling them back, but only after a 7 block waiting period.This period gives time for a counterparty to detect the pending Withdraw and publish any co-signed trades or transfers that have already been agreed to, this prevents welching on trades. The other major benefit of the Withdraw model is it decouples custody keys from trading keys.In other words, you can Commit tokens by building a transaction and signing it on an airgapped computer, copy the PBST string between screens to maintain the gap, and then later issue a Withdraw to pull the tokens back.Just like how centralized exchanges work, having various controls and the ability to shut-off API keys while the underlying funds are kept in something like Fireblocks, with a separate protocol for ordering withdrawals, TradeLayer brings this requirement for professional money management and better retail security to DeFi. Transfer Transfer is how the Layer 2 becomes flexible enough to hot-route capital around between any two channel addresses.Since it’s relatively fast to spin up a new channel with a new counterparty, it’s possible to also quickly build and present a valid Transfer tx to that new counterparty, either signed from your own wallet’s address or pinging a counterparty to liberate funds. PNL Settle Ok so we can put funds onto the layer 2 model, which is relevant because you hold this string ot withdraw it, freeing you to co-sign trades and overrule the withdrawal assuming you haven’t published the trade immediately.And, you can flexibly transfer capital between channels to make this system work like an orderbook.What’s left? To really make a layer 2 scale, you want to save on publishing transactions, just signing them is enough! You can zip trades around, opening and closing positions, booking profits and losses, all day long, just keep signing, your counterparty may be a market maker who is hedging as they sign with you, relying on the option of paying miner fees to publish the trade, but you’re both happy to basically save lots of money and trade almost for free.That’s scaling. The PNL Settle transaction makes this possible.The Token and Contract Channel Trade transactions have an expiration block, usually a few blocks ahead of when they are made, this is to prevent abuse of Counterparty Value Adjustment, where the party holding the partially-signed trade might wait for seconds or minutes to co-sign, the partial signature is like a free option.Filtering against abusive traders can help, binding to a smart contract and enforcing a tighter time-limit based on NEAR’s 300ms block interval could overkill the problem, but TradeLayer by default has the expiration parameter as a base.The PNL Settle includes as a parameter the txid of the transaction you would have published, if you publish the PNL Settle then that transaction would be invalid in TradeLayer’s consensus logic, it’s like txid blacklisting. Therefore it’s possible to refresh a transaction every few blocks by pinging back and forth and producing a PNL Settle and a new trade.You can ping pong like that all day long, keeping a position alive, or you can do a settle based on the price of a closing trade.Imagine you signed a long trade with a market maker, the market goes down, a few blocks pass, you PNL Settle a loss and make a new long trade at the mark price matching the PNL Settle’s value, then the market keeps dumping, you dump the long, you make another PNL Settle neutralizing that 2nd trade and neglect to make a new trade. By using base 94 ASCII encoding it’s possible to crunch txid’s down to 30 bytes and pack 2 of them in the OP_Return, meaning it’s possible to neutralize the previous PNL Settle and the previous trade update.Don’t want to keep trading, don’t make a new transaction, instead add in to the OP_Return a mark price and an update flag to update the first txid of the latest trade and only invalidate the txid of the last PNL Settlement; this way each PNL Settlement is final and you don’t need to hold on to tons of these to publish later. This flexibility seems a bit complicated if you were keeping track of it by hand but it can all fit into wallet code and run seamlessly.In this way, we can potentially achieve insane levels of transaction throughput at ultra-low latencies with average protocol and miner fees approaching 0 as market makers do more flow with high frequency liquidity takers.It’s a unique approach compared to the rest of DeFi with radical potential to provide market structure for global transactions, millions a day, even hundreds of millions. And when you do publish, the fee is 0.5 bps. Last updated: [1072024] "},"protocol/DERIVATIVES.html":{"url":"protocol/DERIVATIVES.html","title":"Derivatives","keywords":"","body":"Derivatives The default derivative is a perpetual swap, which is the base of what the protocol calls a Contract Series, each new contract series gets a contractId which corresponds to the perpetual. Futures Based on the parameters of the series, there is a block interval N where a number of futures contracts Y will be settling, the bigger Y is the more N*Y intervals in the future there exist live futures contracts.A reasonable value for N is the number of Litecoin blocks in a week (4032) or month (17280), but since a month is uneven (leaving 5 days off the year and thus slipping over the years) it’s also recommendable to choose 52560 for a quarterly futures contract.Once a futures contract expires a new futures contract is generated.The contractId for futures starts with the Id of the parent perpetual swap, followed by a hyphen, followed by the blockheight of its expiry. Perpetual Funding There is no built-in interest rate in the funding formula for futures, there is a clamp where +/- 5 bps is ignored and given a 0 funding rate.Any average contract VWAP above the average oracle value or underlying token index will produce a funding rate of that difference minus the 5 bps clamp, and likewise an average VWAP that is discounted more than 5 bps will produce negative funding equal to the discount plus 5 bps.Funding settles hourly, which creates lots of arbitrage opportunities against other contracts.Additionally, the clamp makes it easier for the contract to swing in the 10bps range around the index and TradeLayer’s low fee makes basis trading effective in that range. Options Later, options will be activated and are based on the contract series numbering: Info: n-expiry-P-strike With N as the underlying contractId of the original perp swap, the expiry block like with futures (it can be a block height other than futures) the Call or Put code C or P added after a hyphen, then the strike price.The protocol rounds strikes to the latest round number based on a 1% increment or a 2.5% increment for expirations >1 month.Trades are all based on channel execution and assumed to be bilateral, thus the payloads can be customized even though the rounding rules standardize strikes to some extent. An option series can be European or American style, American delivers into the nearest-expiry future that is existent in the original contract series (expirations can be different) and that is closer to or equal to the expiration of the American style option. American options tend to be more expensive to price in the time value of money from possibly taking delivery and liquidating/reinvesting/cash-carry-hedging the underlying. If there are no futures with expiry block Cross-margin TradeLayer does not support universal portfolio margin across multiple forms of collateral as this creates complex systemic risks based on correlation between collateral assets and covariance in different mis-matched collaterals and contract denominations.It does support automatic cross-margin within single collateral properties, thus perps, futures and options can all offset each other based on block-by-block settlement automatically.Even if contracts are illiquid in terms of trading volume each block they are marked to model based on time to expiry, recent premium and the mark price of the perp, which is the TWAP of the last few oracle publications or the VWAP of the underlying token index for native contracts. Expiration Futures expire into Perps if native or cash-settle if oracle based.Options are European style and likewise settle into Perps if native or cash if oracle. Last updated: [1072024] "},"protocol/INSURANCE.html":{"url":"protocol/INSURANCE.html","title":"Insurance and Liquidation","keywords":"","body":"Insurance and Liquidation Liquidation Price and Process In TradeLayer, liquidation is a critical mechanism designed to protect the protocol and maintain stability in the face of adverse market conditions. The process leverages both Liquidation Price Calculation and an Incremental Liquidation Mechanism to efficiently manage under-collateralized positions. Liquidation Price When a liquidation event is triggered, liquidators can specify the product and the amount they intend to liquidate. The liquidation price is calculated based on whether the contract is linear or inverse and whether the position is long or short. This price serves as a threshold that, if reached, initiates liquidation actions on the user's position. Liquidation Price Linear Contracts For linear contracts, the liquidation price calculation depends on whether the position is long or short: Long Positions: The liquidation price ( L ) is calculated after determining the bankruptcy price ( B ), where: $$ B = \\left( P_{\\text{avg}} - \\frac{\\text{Total Collateral}}{\\text{Position Notional}} \\right) \\times 1.005 $$ Here, ( P_{\\text{avg}} ) is the average entry price, and the 1.005 factor applies a 0.5% buffer above the bankruptcy price. The liquidation price ( L ) is then given by: $$ L = B + \\frac{(P_{\\text{avg}} - B)}{2} $$ Short Positions: The bankruptcy price ( B ) is calculated as: $$ B = \\left( P_{\\text{avg}} + \\frac{\\text{Total Collateral}}{\\text{Position Notional}} \\right) \\times 0.995 $$ This applies a 0.5% buffer below the bankruptcy price. The liquidation price ( L ) is then: $$ L = B - \\frac{(P_{\\text{avg}} + B)}{2} $$ Inverse Contracts For inverse contracts, where the notional value is expressed inversely, the calculations differ slightly: Long Positions: The bankruptcy price ( B ) is: $$ B = \\frac{\\text{Position Notional} \\times 1.005}{\\text{Total Collateral}} $$ The liquidation price ( L ) is then determined by balancing the average price, the notional, and the bankruptcy price: $$ L = P{\\text{avg}} - \\frac{\\left( P{\\text{avg}} \\times \\text{Position Notional} - 2 \\times P{\\text{avg}} \\times \\text{Contracts} - B \\times \\text{Contracts} \\times 1.000025 \\times P{\\text{avg}} \\right)}{\\text{Contracts} + \\text{Position Notional} - 2 \\times \\text{Contracts}} $$ Short Positions: For short positions, if the total collateral exceeds the notional value, there is no immediate liquidation; otherwise: $$ B = \\frac{\\text{Position Notional} \\times 0.995}{\\text{Total Collateral}} $$ And the liquidation price ( L ) follows as: $$ L = P{\\text{avg}} + \\frac{\\left( P{\\text{avg}} \\times \\text{Position Notional} - 2 \\times P{\\text{avg}} \\times \\text{Contracts} - B \\times \\text{Contracts} \\times 1.000025 \\times P{\\text{avg}} \\right)}{\\text{Contracts} + \\text{Position Notional} - 2 \\times \\text{Contracts}} $$ Bankruptcy Price Calculation The bankruptcy price determines the threshold at which the liquidation buffer adjusts the calculated liquidation price slightly closer to market conditions. This calculation considers total collateral relative to the position's notional value. The buffer factor (1.005 for long positions and 0.995 for short positions) provides a slight cushion, increasing the liquidation price or decreasing it respectively, which reduces volatility impact during forced liquidations. The bankruptcy price is primarily calculated using: $$ B = \\left( \\frac{\\text{Collateral}}{\\text{Position Notional}} \\right) \\times \\text{Buffer Factor} $$ Where: Buffer Factor is a multiplier (e.g., 1.005 for long positions) applied to set the liquidation price slightly beyond the actual bankruptcy price, mitigating risks and covering potential slippage costs during liquidation. Summary By using these formulas, the system calculates liquidation prices dynamically based on the position type (long or short) and contract type (linear or inverse). Liquidators are incentivized through a buffer margin, while the insurance fund supports the system stability in cases of insolvency. This framework provides a balanced approach to ensure protocol resilience and fairness during market downturns. In addition to the hard hand-brake liquidation price, the maintenance margin is half of the initial margin and triggers incremental liquidations of 20% of the position. Liquidation Process Step-by-Step Liquidation Trigger: When a user’s margin falls below the required maintenance level, the system marks the position for liquidation. Selection: Perps are presumed to be the most liquid and sold first, then futures, then short options are covered. If there are off-setting positions the net-delta of the address in that collateral and contract series will be reduced closer to 0. Execution: Liquidation by default goes to the on-chain orderbook, which depending on AMM depth, could become know as the wood chipper by users. In the future it may be possible to flash a dutch auction starting at the maintenance price until the bankruptcy price for channel traders to single-sign a trade with the liquidation flag and front-run the AMM, which could greatly improve price execution. Insurance Fund Intervention When liquidators liquidate positions, the insurance fund steps in as follows: Draws from Insurance Fund: If an account is insolvent (i.e., liabilities exceed collateral), funds from the insurance fund are deployed to cover the deficit. Socializes Losses: If the insurance fund is depleted, the system socializes losses across all positions based on the proportion of uPNL. Final Defense Mechanisms Insolvent Accounts: For accounts with insufficient USDC or collateral, the insurance fund provides additional liquidity to ensure that liquidators are compensated and the protocol remains solvent. Socialization of Losses: In extreme cases where the insurance fund is insufficient, losses are socialized across all positive balances, reducing each stakeholder’s balance proportionally to cover the deficit. The insurance fund thus plays a crucial role in maintaining protocol stability and protecting the system from cascading failures during adverse market conditions. Last updated: [1082024] "},"protocol/FEE.html":{"url":"protocol/FEE.html","title":"Fees","keywords":"","body":"Fees The basic fee in TradeLayer is 0.5 bps total, though on-chain token trades have a rebate value that takers pay to makers in order to make wash-trading and manipulation of price data prohibitively expensive. Trade Type Taker Fee Maker Fee Channel Token 0.25 0.25 Channel Oracle Contract 0.25 0.25 Channel Native Contract 0.125 0.125 On-chain Token -3.5 4 On-chain Contract -0.5 1 A quarter of the fees in oracle contracts go to buy back the $TL (Litecoin), $TD(Dogecoin) and $TB (Bitcoin) native tokens and deposit them in the insurance fund for the native TL/LTC contract, which backs synthetic Litecoin.A quarter is cached until a minimum threshold is reached and then distributed to holders of the TLI token or equivalent on other chains.The other half goes to the administrator publishing the oracle feed, as revenue. Half of the fees from native contracts and tokens goes to buyback the TL token or its cousins on other chains and the other half goes to cache until a threshold is met and then is distributed to TLI token holders. More on that in the next article. Last updated: [1082024] "},"protocol/TOKENOMICS.html":{"url":"protocol/TOKENOMICS.html","title":"Vesting and Tokenomics","keywords":"","body":"Vesting Tokens TL and TLVEST There is a supply of 500,000 TL tokens which is the exclusive form of native collateral that can be used to mint synthetic currency.Of this, 100,000 are instantiated inside the insurance fund for the contractId 1, the native TL/LTC contract, 150,000 are loose and 250,000 are tied to TLVEST tokens that vest based on the cumulative LTC spot volume in the protocol, on a linear scale starting from 1000 LTC to 100,000,000.At 1M LTC cumulative volume ~0.999% of those TLVEST tokens will yield liquid vesting tokens, at 10M LTC the number will be close to 10% and at 100M LTC all of the 250k TLVEST tokens will have yielded the TL tokens associated.TLVEST cannot be traded in the protocol but it can be sent. 50,000 TL will be sold initially to get liquidity going. 50,000 TL will be used to mint synthetic LTC against the Native TL/LTC Perpetual Swap settling off of the liquidity of the above 50k. 150,000 TL will be auto-deposited on initialization of the protocol to the insurance fund for the TL/LTC perpetual swap. This insurance fund accumulates buybacks with half of the fee revenue. 250,000 TL are reserved in Vesting Tokens that will be 50% vested when the cumulative spot volume of the protocol is around 500 million LTC 100% will be vested when the cumulative LTC spot volume reaches 1 billion LTC. Different ratios will apply to $TB and $TD on Bitcoin and Dogecoin. The Doge tokenomics will be more inflationary and the BTC tokenomics will be focused on a fair launch with no initial liquid supply. TLI and TLIVEST Farming and Airdrops It’s important that a DEx protocol has a reward for traders who make the DEx liquid and useful with their participation, especially in the early days of going from 0 liquidity to 1 liquidity.Like Homer Simpson said, I have 3 kids and 0 money, I wish I had 0 kids and 3 money.The early market makers who enable a DEx to have 3 money are very valuable and deserve a stake in the success of the DEx for that participation, but also this idea has been played out since DeFi summer 2020 to the effect usually of extreme token inflation, perp markets that price in huge negative funding for the dividend effect, unsophisticated retail buyers who can’t price in all these variables, and eventually a massive dumping of the token as cynical farmers insta-stell their earned tokens. After a cycle of that showed us a series of charts with massive spiked to multi-billion dollar valuations (fully diluted) followed by massive dilution and 98% drawdowns, followed by maybe 300% pumps, this market cycle has given us the airdrop event.This builds FOMO in users who come try out the new pre-token product, producing a lot of numbers such as volume or Total Value Locked that seem like real traction, and then the event happens, people often isnta-sell and move on to the next anticipated airdrop.Sometimes the token pumps for a 2-5x afterwards but since they debut at something like 1B FDV the real revenue of the product, maybe an impressive >10M a year, can’t justify those valuations and the same result happens. Rebate Programs Some DExes that are fee competitive and reasonably fast have offered tokens that yield to trades based on measured programs, rather than a built-in perpetual algorithm, and these distribute much or all of the revenue of the DEx to holders and/or stakers, but the dilution causes quick dumping as traders try to recover a fraction of their monthly trading fee expenditure.The result is a market cap that goes mostly sideways while the token price sags. This last incarnation isn’t so bad, the yield from the revenues off-sets the price drops and eventually the dilution slows down and the thing bottoms, and then the combined price recovery and yield makes it an attractive hold.Meanwhile it has the effect of subsidizing trade activity in part.One problem is that the managed promotional periods are not predictable for users and involve the centralized administration of what seems to be a common enterprise, a truly decentralized protocol should replace that with a more elegant mathematical formula that anyone can predict and anticipate both the dilution and the effect at-the-market discount to fees that the token rebate represents. Long-term Vesting Now a wrinkle: what if people can’t easily dump the rebate? You make the rebate a Vesting Token that involves a future expectation.This offsets the immediate dilution, people can try to OTC sell their VTs at a discount of they’re major MMs and hold size, or broker an OTC buy and reach out to scoop lots of modest positions from medium-sized traders, but then flipping those still involves a long-term expectation of revenue growth or at least stability.This market effect offsets the immediacy of selling and encourages collection of the income interests in stronger hands. Therefore our approach is to rebate trades on two levels: one based on whitelisting for the early program to create Sybil resistance, wash traders will be revoked.This rebate will be higher than the fee rate in terms of expected current market value.The baseline rebate will be initially equal to the fee and decline logarithmically as the cumulative volume on the DEx increases through orders of magnitude in LTC equivalent, eventually resting at about 10% of the fee rate after years of scale volume.This makes wash trading still expensive and is economically Sybil resistant. The TLIVEST tokens will vest on a logarithmic scale from 10M LTC cumulative volume to 1T LTC cumulative volume, unlike the TLVEST tokens that are linear up to 100M LTC, 20% of the TLIVEST tokens will vest by 100M LTC, another 20% by 1B, another 20% by 10B, then another 20% by 100B and the last 20% approaching 1T.The rebates will come pre-vested proportionate to the total historical volume of the DEx at these times. Why two tokens? While it adds some confusion and dilutes brand value, the choice of decoupling native collateral from trade incentives is necessary to make the collateral backing deflationary while enabling calibrated inflation for the dilutive incentives.It’s like how central banks hold gold and issue liabilities, one is there to keep the system stable in emergencies and keep the central bank operational, the other is there to juice the growth of the economy and earn out over time. Having the native coin be the core collateral for synthetic currency that is meant to reduce-risk and be useful collateral in ways that UTXO money cannot currently serve.If an exchange’s deposits are all risky liabilities backed by the discounted cashflows of the exchange, like say FTX when their books were based on FTT margin and internal loans to their captive hedge fund, there’s a horrible correlation between the decline in those liabilities market value and the decline in the expected future cashflows of the venue.In other words, scheme make crash worse, kill everything, super bad.Another terrifying example of this was the LUNA/UST model.TradeLayer’s design has gone through iterations since 2017 and learned the lessons from the deca-billion sized failures of the past. More on this in the next article. "},"protocol/MACRO.html":{"url":"protocol/MACRO.html","title":"Macro-economics","keywords":"","body":"Macro-economics Escaping Debt-money Backing stablecoins with derivatives and cryptocurrency is an alternative to debt-based money that took over the world in the last 150 years and that continues to dominate DeFi in the form of US treasury bill-backed stablecoins.Commodity money systems lack the political guarantees and infinite printing press of debt-based systems, but they also are free of the blood on the hands of world powers and the extractive effect of inflation and interest-driven rent-seeking, there’s a moral imperative and a practical imperative to at least creating a second type of money.The free flow of capital is also threatened by centralized control and this can entrap people in failing currencies with high inflation - now that we’ve covered the classic crypto-libertarian talking points let’s analyze the downsides. LUNA and UST were based on the same model as penny stocks where the insiders can’t raise 100k dumping shares but they can take a 100k note from a shark lender who gets unlimited dilution rights to dump on retail, retail comes in for a pump from a penny to a nickel and the share supply ends up going from 100M to 10B and the price ends up at 0.0001 USD, the lender gets 50k profit out of the deal.Not great. If LUNA had perpetual swaps backing each UST with notional value and the inverse-quoted supply of LUNA that future longs would provide as they buy the liquidations of other longs, then UST wouldn’t have had that sweet 20% Anchor interest rate, it’d have faced variable yield and negative funding in hard times.With inverse contracts you lose twice as many tokens to back the same # of USD liabilities each 50% drop, so LUNA going from $100 to $50 is one cycle, $25, $12.5, $6.25, $3.125, that’s five doublings. The 10B in UST liabilities would have crunched in half at least once as people redeemed for LUNA to escape negative perp funding and continued dumping tokens, fueling more liquidations, but maybe just maybe, at $3 around a 1B valuation LUNA could have stabilized based on fee revenues now at a modest 40x Price/Earnings ratio and a public memetic perception of moneyness and future value in the ecosystem.Maybe the insurance fund would have emptied out and UST holders would have taken hits of perhaps 10% in perp-swap socializations as liquidations cascaded, losing 500M, the doubling of the money supply would lead to a lower range and cap any rallies in the $10-20 range, but speculators would have gone for it and the system could have lived to fight another day.If there was real demand for UST as an alternative to USDT or USDC that could have floated things along, stabilized yields slightly above 0, and lead people to, as Journey would say, not stop believing. Stonks Consider examples in the stock market where corporate buybacks failed to juice returns; Facebook/META sterilizing employee option grants with debt-fueled buybacks isn’t a great example, a great example is JC Penny.JC Penny is a real business based on real goods in real locations with real logistics, bought by real moms who want real clothes.Unlike DEx fees in a race to the bottom, relentlessly gunning for volume expansion based on more minute liquidity increments, JC Penny is only going to sell so many blouses in a year, competing with Target and many others, economy-priced but the margins are still decent, paying rent on shelf space, but with room for optimizations in supply chain, marketing, or even just raising prices and optimizing the demand curve.JC Penny’s revenue has room to grow, not by an order of magnitude, but maybe by 30%.However the stock declined from ~$23 to $0.18 during COVID, where they filed for bankruptcy from the revenue freeze vs.all that debt they issued.They ended up bought out by a Private Equity group, the ultimate OTC sale, restructured their 4B in debt and have it down to 500M 4 years after their equivalent of the LUNA crash. If JCP had not used leverage to buyback the shares and just used free cashflow, they’d probably still be a public company, and the natural decline of the stock would have been met with an accelerated reduction in float.Maybe they’d even see $23 again, even if at half the market cap or lower.That’s supply deflation.It’s worth considering that the moneyness of a token that is used as backing for a decentralized stablecoin is based on its perceived value-retention while people load up liabilities against it, the derivatives represent a liability for any leveraged long (which, for inverse-quoted contracts, is all longs) and the 100% backed short positions (the decentralized stablecoin) represent the sum of those liabilities, because those holders are really counting on the longs staying solvent even if there is a line of dip buyers behind the liquidation of the current longs. Debt Fiat is stability, yet, fiat is debt, and debt is instability, this is the paradox of money we face when we contemplate stablecoins.Only debt backed by the world’s most powerful empires and their humanity-annihilating military capability has the existential weight of escaping this paradox, until the world order fractures.Like with the FTX bankruptcy, you might think it’s not worthing thinking about that because what kind of world would that be anyway, but thinking about that is rather the whole point of this project that started with the Bitcoin whitepaper on Oct.31 2008, and the Chancellor on the brink of the second bailout for banks. Ray Dalio called the post 2009 QE system a “beautiful deleveraging” though the results were a decade of bizarre zombie economics, WeWork, millennial consulting jobs, crypto pumps and other distortions of market signals.Yet a beautiful deleveraging of the politically captured status quo of debt money may be possible through peaceful co-ordination of many nations rallying energy resources to power Proof of Work cryptocurrency, a vision like Buckminster Fuller meets Milton Friedman. Bitcoin Futures We’re obviously not Bitcoin Maximalists because we’re not obeying religious dogmas about only using UTXOs.But we are Bitcoin Minimalists.Bitcoin as money is going to be an essential component of this picture.There should be room for something like Scrypt to drive similar energy economics and provide additional block capacity and fee competition to Bitcoin, but ultimately sLTC and sBTC are going to be a phase 2, with phase 1 being reliance of supplementary liquidity from debt-based stablecoins, and phase 3 will be tapping into the BTC and adjunct money supplies directly as the power money behind our decentralized stablecoin working capital. Consider Ethena, this is an attempt to bypass all the operational risk of DeFi, from contract quirks to layer 2 shuddering to regulatory twists to oracle lapses to restaker liquidity crises, and just put some tokens on Derbit, Binance et al.and hedge them with the most liquid CeFi perps, then mint a token backed by that, wrap it in an off-shore Trust and call it a stablecoin.It’s done reasonably well though it seems unlikely to overtake USDC and USDT due to the scale limitations of its yield-harvesting model.As US regulated futures list smaller-scale contracts at competitive fee rates, a lot of capital will come in to both go long and capture the cash-carry yield from the contract premiums, this will compress yields and increase Open Interest overall, effectively increasing the total supply of centralized BTC and ETH-backed synthetic dollars and competing with USDT+USDC for total size. For Bitcoin, probably OP_Cat is going to get activated, facilitating Taproot Lamport signatures for Quantum resistance, multiple KB publishing of ZK proofs, and BitVM contraptions to lock BTC into sidechains where we can have semi-centralized perps instead of the centralized ones Ethena is remarketing.Infrastructure like this could beef up the Chain Abstraction roadmap we’re pursuing and make the vaulting of UTXOs more interactive with smart contracts with cleaner virtualization of chain state; in other words instead of putting the blocks on a chain and implementing Bitcoin or Litecoin in smart contracts to re-create state the hard way, we can make ZK proofs off-chain and verify them in smart contracts and wrap decentralized deposits of BTC in multisigs controlled by those contracts and settle decentralized derivatives that way.The last 20% of the technical puzzle isn’t totally clear at this time of launch but there’s room in TradeLayer’s tx types for additional modularity to complete the picture.Ooh, it’s a lighthouse, what a rewarding puzzle to complete. Last updated: [1082024] "},"protocol/COMPLIANCE.html":{"url":"protocol/COMPLIANCE.html","title":"Compliance","keywords":"","body":"Compliance TradeLayer has a whitelist feature built-in, taking up a few tx types, for creating new whitelists and issuing/revoking attestations from that admin address.Like oracles and token issuer addresses, there’s a back-up address parameter and an update admin transaction type to refresh multisig security protocols, update to quantum-resistant addresses when those come out, and so on.The protocol uses two lists to verify who qualifies for delux rebates in the early stages of the protocol launch and which centralized oracles and tokens qualify to be included in cumulative LTC-equivalent volume for vesting and rebates. Centralized issuers can use whitelists to gate who can trade their security tokens, contracts or stablecoins, in order to comply with relevant regulations as needed.Their policies for issuing and revoking addresses from the lists can be tailored to regulatory requirements off-chain and administered. The mainnet release of the wallet will have IP verification and VPN detection to lock the wallet from being used by US persons.Even spot trading, unfortunately, is disabled for US persons as the 6050i rule puts criminal liability on transacting This is designed to keep things as unrestricted for most of the world’s users and as smooth as possible while giving people who need the information the ability to filter counterparties or implement issuance policies. Last updated: [1082024] "},"api_reference/TRANSACTIONS.html":{"url":"api_reference/TRANSACTIONS.html","title":"TradeLayer Transactions","keywords":"","body":"Transaction Types Activation Description: Sets up and activates various functionalities within the TradeLayer ecosystem.There are multiple activations, each enabling a specific set of transactions. Once the finite activations are expended this transaction loses all power. Parameters: txTypeToActivate: The transaction type to be activated. block: The block at which the activation takes place. Send Description: Allows users to send tokens from one address to another. Parameters: sendAll: Boolean indicating if all tokens should be sent. senderAddress: The address initiating the transaction. recipientAddresses: Array of recipient addresses. propertyIds: Array of token property IDs to be sent. amounts: Array of amounts to be sent for each property. block: The block in which the transaction occurs. --- ### Token Issue Description: Issues a new token, which can be managed, fixed, or non-fungible. Parameters: sender: The address of the token issuer. initialAmount: The total amount of the token at issuance. ticker: The symbol of the token. url: URL related to the token (optional). whitelistId: The whitelist ID associated with the token. isManaged: Boolean indicating if the token is managed. backupAddress: An alternate address for token management. isNFT: Boolean indicating if the token is non-fungible. block: The block in which the transaction occurs. Trade Token for UTXO Description: Facilitates trading of a token in exchange for UTXOs. Parameters: senderAddress: The address sending the token. satsPaymentAddress: The address receiving the Litecoin. propertyId: The ID of the token being traded. amount: The amount of tokens to be traded. columnA: Boolean indicating which column is involved in the trade. satsExpected: The expected amount in satoshis. tokenDeliveryAddress: The address receiving the tokens. satsReceived: The actual amount received in satoshis. price: Price per token. paymentPercent: The percentage of the payment. block: The block number of the transaction. txid: Transaction ID for reference. Commit Token Description: Commits tokens to a specific purpose, such as creating a reserve. Parameters: senderAddress: The address committing the tokens. channelAddress: The address of the channel where tokens are committed. propertyId: The ID of the property/token being committed. amount: The amount being committed. On-Chain Token-to-Token Trade Description: Executes a token-to-token trade directly on-chain. Parameters: fromAddress: The address initiating the trade. offeredPropertyId: The property ID being offered. desiredPropertyId: The property ID desired in exchange. amountOffered: The amount of the offered property. amountExpected: The amount expected in return. stop: Boolean indicating if this is a stop order. post: Boolean indicating if this is a post-only order. Cancel Order Description: Cancels an existing order in the order book. Parameters: fromAddress: The address requesting the cancellation. isContract: Boolean indicating if the order is for a contract. offeredPropertyId: The offered property ID. desiredPropertyId: The desired property ID. cancelAll: Boolean indicating if all orders should be canceled. cancelParams: Parameters for specific order cancellation. Create Clear List Description: Creates a new clear list with specific criteria. Parameters: adminAddress: The address of the admin managing the clear list. name: The name of the clear list.- url: URL associated with the clear list. description: Description of the clear list. backupAddress: Backup admin address. Update Admin Description: Updates the admin address for tokens, oracles, or other entities. Parameters: whitelist: Boolean for updating a whitelist admin. token: Boolean for updating a token admin. oracle: Boolean for updating an oracle admin. id: The ID of the entity to update. newAddress: The new admin address. updateBackup: Boolean indicating if the backup admin should also be updated. Issue or Revoke Attestation Description: Issues or revokes an attestation for an address. Parameters: clearlistId: The clear list ID. targetAddress: The address for the attestation. clearlistRegistry: The clear list registry. metaData: Metadata for the attestation. revoke: Boolean indicating if this is a revocation. AMM Pool - Description: Handles AMM (Automated Market Maker) pool actions like adding or redeeming capital. Parameters: sender: The sender's address. block: The block number. isRedeem: Boolean indicating if it's a redeem action. isContract: Boolean indicating if the transaction involves a contract. id: ID of the property or contract involved. amount: Amount for the transaction. id2: Secondary ID for pairs (optional). amount2: Secondary amount (optional). Grant Managed Token Description: Grants managed tokens to a recipient. Parameters: propertyId: ID of the token property. amount: The amount to grant. recipientAddress: The recipient's address. propertyManager: The property manager instance. Redeem Managed Token Description: Redeems managed tokens from an address. Parameters: - propertyId: The property ID. amount: Amount to redeem. address: The address initiating the redemption. Create Oracle Description: Creates a new oracle with specific parameters. Parameters: adminAddress: Admin address for the oracle. ticker: Ticker symbol for the oracle.- url: URL for the oracle. backupAddress: Backup admin address. clearlists: Clearlists associated with the oracle. lag: Oracle data lag time. oracleRegistry: Registry for oracles. Publish Oracle Data Description: Publishes data to an existing oracle. Parameters: oracleId: The ID of the oracle to publish data to. price: The price data to publish. high: The high value for the data period. low: The low value for the data period. close: The close value for the data period. Close Oracle Description: Closes an existing oracle, stopping further data publishing. Parameters: oracleId: The ID of the oracle to close. Create Contract Series Description: Creates a new futures contract series with parameters like leverage, collateral, and expiry. Parameters: sender: Address creating the series. native: Boolean indicating if the contract is native. underlyingOracleId: The ID of the underlying oracle for the contract. onChainData: Data required for on-chain execution. notionalPropertyId: Property ID for notional value. notionalValue: The value for notional amount. collateralPropertyId: Collateral property ID. leverage: Leverage factor for the contract. expiryPeriod: Expiry period of the contract. series: Series identifier. inverse: Boolean indicating if the contract is inverse. fee: The transaction fee for the series. block: The block when the series is created. whitelist: Whitelist associated with the series. Exercise Derivative Description: Exercises an existing derivative contract. Parameters: contractId: The ID of the contract to exercise. amount: The amount to exercise. contractsRegistry: Registry instance for contracts. Trade Contract On-Chain Description: Executes an on-chain trade for a futures contract. Parameters: contractId: The ID of the contract being traded. price: The price for the contract. amount: The amount of the contract. sell: Boolean indicating if the trade is a sell order. insurance: Insurance details for the trade. blockTime: Block timestamp. txid: Transaction ID. sender: Address executing the trade. reduce: Boolean indicating if this is a reduce-only order. post: Boolean indicating if this is a post-only order. stop: Boolean indicating if this is a stop order. Trade Contract Channel Description: Executes a trade for a contract within a specified channel. Parameters: contractId: The ID of the contract being traded. price: The price at which the contract is traded. amount: The amount being traded. columnAIsSeller: Boolean indicating if Column A is the seller. expiryBlock: Expiry block for the contract. insurance: Insurance details for the contract. channelAddress: Address of the trading channel. Trade Tokens Channel Description: Facilitates token-to-token trade within a specific channel. Parameters: offeredPropertyId: The ID of the token being offered. desiredPropertyId: The ID of the token being requested. amountOffered: Amount of the offered token. amountDesired: Amount of the desired token. expiryBlock: Expiry block for the trade. columnAIsOfferer: Boolean indicating if Column A is the offerer. channelAddress: The address of the trading channel. Withdrawal Description: Withdraws a specified amount of tokens from a channel. Parameters: withdrawAll: Boolean indicating if all tokens should be withdrawn. channelAddress: Address of the channel. propertyId: The property ID for the tokens being withdrawn. amount: The amount to withdraw. sender: The address initiating the withdrawal. block: The block number when the withdrawal occurs. columnIsB: Boolean indicating if Column B is involved in the withdrawal. Transfer Description: Transfers tokens from one channel to another. Parameters: fromChannelAddress: The channel address initiating the transfer. toChannelAddress: The destination channel address. propertyId: The ID of the property being transferred. amount: The amount to transfer. isColumnA: Boolean indicating if Column A is the source column. block: The block number when the transfer occurs. Settle Channel PNL Description: Settles profit and loss for a specific trading channel. Parameters: propertyId amount keepingTrade (boolean) txId negated (base 94 encoded) txId negated (if keepingTrade is false) mark price (if keepingTrade is true) Mint Synthetic Description: Mints new synthetic tokens based on an existing property and contract. Parameters: address: Address to receive the synthetic tokens. propertyId: The collateral property ID. contractId: The contract ID. amount: Amount of synthetic tokens to mint. grossRequired: Gross amount required as collateral. contracts: Number of contracts. margin: Margin required for the transaction. Redeem Synthetic Description: Redeems synthetic tokens for the underlying collateral. Parameters: address: Address initiating the redemption. propertyId: The ID of the synthetic token. contractId: The associated contract ID. amount: The amount to redeem. Pay To Tokens Description: Distributes one type of token to holders of another. Parameters: propertyIdTarget: ID of the target property. propertyIdUsed: ID of the property used for payment. amount: The total amount for distribution. address: Address initiating the distribution. Create Option Chain Description: Creates an options chain with specified strike intervals and style. Parameters: seriesId: ID of the options series. strikePercentInterval: Interval for strike prices. expiryNumber: number of contracts in the series expiryInterval: blocks between expirations for contracts in the series isEuropeanStyle: Boolean indicating if the options are European style. Trade Bai Urbun Description: Facilitates an Islamic Bai Urbun trade within a channel. Parameters: channelAddress: Address of the trading channel. propertyIdDownPayment: Property ID for the down payment. propertyIdToBeSold: Property ID for the item to be sold. downPaymentPercent: Down payment percentage. amount: Total amount for the trade. expiryBlock: Expiry block for the trade. tradeExpiryBlock: Trade expiry block. Trade Murabaha Description: Executes a Murabaha trade where the cost and profit margin are predefined. Parameters: channelAddress: Address of the trading channel. buyerAddress: Address of the buyer. sellerAddress: Address of the seller. propertyId: Property ID for the trade. costPrice: Cost price for the goods. profitMargin: Profit margin for the seller. paymentBlockHeight: Block height for payment. Issue Invoice Description: Issues an invoice for a specified amount and due date. Parameters: propertyManager: The property manager instance. invoiceRegistry: Registry instance for invoices. propertyIdToReceivePayment: Property ID to receive payment. amount: Amount for the invoice. dueDateBlock: Due date block. propertyIdCollateral: Collateral property ID (optional). receivesPayToToken: Boolean for pay-to-token collateral. issuerNonce: Nonce for the issuer. Batch Move ZK Rollup Description: Processes a batch of transactions using zero-knowledge rollups. Parameters: zkVerifier: Verifier for zero-knowledge proofs. rollupData: Data for the rollup batch. zkProof: Zero-knowledge proof for the rollup batch. Publish New Tx Description: Publishes a new transaction type with accompanying code. Parameters: ordinalRevealJSON: JSON data for the ordinal reveal. jsCode: JavaScript code associated with the transaction. Bind Smart Contract Description: Tags the sender address as having keys controlled by Parameters: contractHash: identifier for the contract address on the foreign chain controlledKeys: number of keys on the address controlled by the contract thresholdKeys: number of signatures needed to sign a tx from this address (if multisig) maximumKeys: maximum number of keys on the address (if multisig) ordinalRevealCode: Code for the contract can be found in the witness data Register and Redeem OP_CTV Covenant Description: Registers or redeems an OP_CTV Covenant transaction. Parameters: To be defined based on specific use case requirements. Mint Colored Coin Description: Mints a new colored coin with specific properties. Parameters: To be defined based on specific use case requirements. Last updated: [1082024] "},"api_reference/API.html":{"url":"api_reference/API.html","title":"Orderbook Service API Package","keywords":"","body":"Rest Endpoints /tl_initmain Description: Initializes the main processor. Parameters: test (boolean, optional) - For testing mode. Response: Success: Main process initialized successfully Error: Error message if initialization fails. /tl_validateaddress Description: Validates a given address. Parameters: address (string) - The address to validate. Response: Success: Validation response object. Error: Error message if validation fails. /tl_getTransaction Description: Retrieves transaction parameters based on the transaction ID. Parameters: txid (string) - The transaction ID. Response: Success: Transaction information object. Error: Error message if retrieval fails. /tl_getChannelColumn Description: Determines the channel column based on the channel and counterparty addresses. Parameters: channelAddress (string) - The channel address. cpAddress (string) - The counterparty address. Response: Success: Channel column information. Error: Error message if retrieval fails. /tl_loadWallet Description: Loads the wallet. Parameters: None. Response: Success: loading wallet Error: Error message if wallet loading fails. /tl_gettransactionsforaddress Description: Retrieves transactions associated with a specific address. Parameters: address (string) - The address to query. Response: Success: Array of transactions for the address. Error: Error message if retrieval fails. /tl_gettransactionforblock Description: Retrieves transactions associated with a specific block. Parameters: blockHeight (number) - The block height. Response: Success: Array of transactions for the block. Error: Error message if retrieval fails. /tl_getMaxProcessedHeight Description: Retrieves the maximum processed block height. Parameters: None. Response: Success: Maximum processed block height. Error: Error message if retrieval fails. /tl_getMaxParsedHeight Description: Retrieves the maximum parsed block height. Parameters: None. Response: Success: Maximum parsed block height. Error: Error message if retrieval fails. /tl_pause Description: Pauses the main processor. Parameters: None. Response: Success: Pause status. Error: Error message if pausing fails. /tl_getAllBalancesForAddress Description: Retrieves all balances for a specific address. Parameters: params (string) - The address to query. Response: Success: Balances for the address. Error: Error message if retrieval fails. /tl_getChannel Description: Retrieves channel information for a given address. Parameters: params (string) - The address to query. Response: Success: Channel information or message if no channel is found. Error: Error message if retrieval fails. Example Response: ```json {\"_id\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\",\"data\":{\"participants\":{\"A\":\"\",\"B\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\"},\"channel\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\",\"commits\":[{\"senderAddress\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\",\"propertyId\":4,\"tokenAmount\":0.00001,\"block\":3348377,\"columnAssigned\":\"B\"},{\"senderAddress\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\",\"propertyId\":4,\"tokenAmount\":0.00001,\"block\":3348528,\"columnAssigned\":\"B\"}],\"A\":{},\"B\":{\"4\":0},\"lastCommitmentTime\":3348528,\"lastUsedColumn\":\"B\"}} --- ### `/tl_createrawtx_opreturn` **Description:** Adds an OP_RETURN to a transaction blob. - **Parameters:** - `txHex` (string) - Transaction hex. - `payload` (string) - OP_RETURN payload. - **Response:** - Success: Transaction with OP_RETURN added. - Error: Error message if creation fails. --- ### `/tl_getProperty` **Description:** Retrieves property data based on property ID. - **Parameters:** - `params` (string) - Property ID. - **Response:** - Success: Property data. - Error: Error message if retrieval fails. **Example Response:** ```json [1,{\\\"ticker\\\":\\\"TL\\\",\\\"totalInCirculation\\\":500000,\\\"type\\\":1,\\\"whitelistId\\\":0}] /tl_listProperties Description: Lists all properties. Parameters: None. Response: Success: Array of properties. Error: Error message if retrieval fails. Example Response: ```json {\"_id\":\"propertyIndex\",\"value\":\"[[1,{\\\"ticker\\\":\\\"TL\\\",\\\"totalInCirculation\\\":500000,\\\"type\\\":1,\\\"whitelistId\\\":0}],[2,{\\\"ticker\\\":\\\"TLVEST\\\",\\\"totalInCirculation\\\":250000,\\\"type\\\":4,\\\"whitelistId\\\":0}],[3,{\\\"ticker\\\":\\\"TLIVEST\\\",\\\"totalInCirculation\\\":1500000,\\\"type\\\":4,\\\"whitelistId\\\":0}],[4,{\\\"ticker\\\":\\\"TLI\\\",\\\"totalInCirculation\\\":1500001,\\\"type\\\":3,\\\"whitelistId\\\":0}],[5,{\\\"ticker\\\":\\\"TJRZT\\\",\\\"totalInCirculation\\\":694258,\\\"type\\\":1,\\\"whitelistId\\\":0,\\\"issuer\\\":\\\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\\\",\\\"backupAddress\\\":\\\"LNmiS6p8z3KuHHx3q6Jf6x6TfcyptE68oP\\\"}],[6,{\\\"ticker\\\":\\\"CELFE\\\",\\\"totalInCirculation\\\":741256,\\\"type\\\":1,\\\"whitelistId\\\":0,\\\"issuer\\\":\\\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\\\",\\\"backupAddress\\\":\\\"LNmiS6p8z3KuHHx3q6Jf6x6TfcyptE68oP\\\"}],[7,{\\\"ticker\\\":\\\"OZGJE\\\",\\\"totalInCirculation\\\":471902,\\\"type\\\":1,\\\"whitelistId\\\":0,\\\"issuer\\\":\\\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\\\",\\\"backupAddress\\\":\\\"LNmiS6p8z3KuHHx3q6Jf6x6TfcyptE68oP\\\"}]]\"} --- ### `/tl_listFeeCache` **Description:** Retrieves fee cache for all properties. - **Parameters:** None. - **Response:** - Success: Fee cache data. - Error: Error message if retrieval fails. **Example Response:** ```json {id:’feeCache’, value:[{id:1, amount:123432.2343},{id:5,amount: 343.23}] /tl_propertyFeeCache Description: Retrieves fee cache for a specific property. Parameters: id (string) - Property ID. Response: Success: Fee cache data for the property. Error: Error message if retrieval fails. Example Response: ```json {id:5,amount: 343.23} --- ### `/tl_getActivations` **Description:** Retrieves the list of activations. - **Parameters:** None. - **Response:** - Success: Array of activations. - Error: Error message if retrieval fails. --- ### `/tl_getOrderbook` **Description:** Retrieves the order book for a given property pair. - **Parameters:** - `propertyId1` (number) - First property ID. - `propertyId2` (number) - Second property ID. - **Response:** - Success: Order book data. - Error: Error message if retrieval fails. --- ### `/tl_getContractOrderbook` **Description:** Retrieves the contract order book. - **Parameters:** - `contractId` (number) - Contract ID. - **Response:** - Success: Contract order book data. - Error: Error message if retrieval fails. --- ### `/tl_listContractSeries` **Description:** Lists series for a specific contract. - **Parameters:** - `contractId` (number) - Contract ID. - **Response:** - Success: Array of contract series. - Error: Error message if retrieval fails. **Example Response:** ```json {\"id\":1,\"data\":{\"id\":1,\"issuer\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\",\"native\":true,\"underlyingOracleId\":0,\"onChainData\":[[0,1]],\"notionalPropertyId\":0,\"notionalValue\":0.0001,\"collateralPropertyId\":1,\"leverage\":5,\"expiryPeriod\":4032,\"series\":5,\"inverse\":true,\"fee\":false,\"whitelist\":0,\"contracts\":{\"expired\":[],\"unexpired\":[{\"id\":\"1-3086534\",\"expirationBlock\":3086534},{\"id\":\"1-3090566\",\"expirationBlock\":3090566},{\"id\":\"1-3094598\",\"expirationBlock\":3094598},{\"id\":\"1-3098630\",\"expirationBlock\":3098630},{\"id\":\"1-3102662\",\"expirationBlock\":3102662}]},\"ammPool\":{\"position\":0,\"maxPosition\":1,\"maxQuoteSize\":10,\"contractType\":1,\"lpAddresses\":{},\"ammOrders\":[]}},\"type\":\"contractSeries\",\"_id\":\"c3ChX43pOXVagVqn\"} /tl_listOracles Description: Lists all oracles. Parameters: None. Response: Success: Array of oracles. Error: Error message if retrieval fails. /tl_listClearlists Description: Lists all clearLists. Parameters: None. Response: Success: Array of clearlists. Error: Error message if retrieval fails. Example Response: ```json {\"_id\":1,\"data\":{\"name\":\"Market Maker Whitelist\",\"description\":\"Market Makers and active traders who do not wash trade.\"}} — ### `/tl_showClearlist` **Description:** Lists all clearLists. - **Parameters:** id - **Response:** - Success: Array of clearlists. - Error: Error message if retrieval fails. **Example Response:** ```json {\"_id\":1,\"data\":{\"name\":\"Market Maker Whitelist\",\"description\":\"Market Makers and active traders who do not wash trade.\"}} — /tl_contractPosition Description: Retrieves the contract position for a given address and contract ID. Parameters: address (string) - Address to query. contractId (number) - Contract ID. Response: Success: Contract position data. Error: Error message if retrieval fails. /tl_tradeHistory Description: Retrieves the trade history for a given property pair. Parameters: propertyId1 (number) - First property ID. propertyId2 (number) - Second property ID. Response: Success: Trade history data. Error: Error message if retrieval fails. Example Response: ```json {\"_id\":\"token-1-0-cbd88a9b-e324-458d-ada8-26be4c57becf-3395569\",\"key\":\"token-1-0\",\"type\":\"token\",\"trade\":{\"offeredPropertyId\":1,\"desiredPropertyId\":0,\"amountOffered\":1e-8,\"amountExpected\":1000000},\"blockHeight\":3395569,\"txid\":\"c59fd0a35bc93979133cda1ae86c235428112c153fbdabed2cbc7ea86e60543f\"} ``` /tl_getInitMargin Description: Retrieves the initial margin for a contract based on price. Parameters: contractId (number) - Contract ID. price (number) - Price of the contract. Response: Success: Returns a number for the amount of collateral id needed at the given price to margin 1 contract.. Error: Error message if retrieval fails. /tl_contractTradeHistory Description: Retrieves trade history for a specific contract. Parameters: contractId (number) - Contract ID. Response: Success: Contract trade history data. Error: Error message if retrieval fails. /tl_fundingHistory Description: Retrieves funding history for a specific contract. Parameters: contractId (number) - Contract ID. Response: Success: Funding history data. Error: Error message if retrieval fails. /tl_oracleHistory Description: Retrieves oracle history for a specific contract. Parameters: contractId (number) - Contract ID. Response: Success: Oracle history data. Error: Error message if retrieval fails. Last updated: [1082024] "},"api_reference/WALLET.html":{"url":"api_reference/WALLET.html","title":"Wallet Integration","keywords":"","body":"Wallet Integration TradeLayer’s Electron-based desktop wallet is an example of how to integrate a wallet with TradeLayer. In the first release the wallet requires both the TradeLayer application inline in the /dist folder and that the litecoind instance packaged with the installer be allowed to reach a full sync on mainnet. In subsequent releases an API-mode will enable users to point at a server hosting a litecoind node with TradeLayer and responding to external requests. Likewise it’s possible to integrate TradeLayer into other web and browser-extension based wallets with an API mode that queries multiple end-points for security. This can be useful for trading, where most of the operations can be executed with javascript or Rust implementations of Bitcoin and Litecoin, such as litecore-lib, Bitcoin-js and others. It’s also possible to package a web wallet with a partial node that relies on the 1000 block persistence checkpoints and only verifies blocks, the correct chain, and transaction validity, parsing for TL transactions and updating state accordingly, this is more robust than an API-dependent wallet mode but much lighter than downloading the entire blockchain and using a C++ RPC client locally. For more about wallet integration partnerships please reach out to desk@tradelayer.org and we’ll be happy to talk through possibilities. Last updated: [1082024] "},"api_reference/ENDPOINTS.html":{"url":"api_reference/ENDPOINTS.html","title":"TradeLayer Endpoints","keywords":"","body":"Rest Endpoints /tl_initmain Description: Initializes the main processor. Parameters: test (boolean, optional) - For testing mode. Response: Success: Main process initialized successfully Error: Error message if initialization fails. /tl_validateaddress Description: Validates a given address. Parameters: address (string) - The address to validate. Response: Success: Validation response object. Error: Error message if validation fails. /tl_getTransaction Description: Retrieves transaction parameters based on the transaction ID. Parameters: txid (string) - The transaction ID. Response: Success: Transaction information object. Error: Error message if retrieval fails. /tl_getChannelColumn Description: Determines the channel column based on the channel and counterparty addresses. Parameters: channelAddress (string) - The channel address. cpAddress (string) - The counterparty address. Response: Success: Channel column information. Error: Error message if retrieval fails. /tl_loadWallet Description: Loads the wallet. Parameters: None. Response: Success: loading wallet Error: Error message if wallet loading fails. /tl_gettransactionsforaddress Description: Retrieves transactions associated with a specific address. Parameters: address (string) - The address to query. Response: Success: Array of transactions for the address. Error: Error message if retrieval fails. /tl_gettransactionforblock Description: Retrieves transactions associated with a specific block. Parameters: blockHeight (number) - The block height. Response: Success: Array of transactions for the block. Error: Error message if retrieval fails. /tl_getMaxProcessedHeight Description: Retrieves the maximum processed block height. Parameters: None. Response: Success: Maximum processed block height. Error: Error message if retrieval fails. /tl_getMaxParsedHeight Description: Retrieves the maximum parsed block height. Parameters: None. Response: Success: Maximum parsed block height. Error: Error message if retrieval fails. /tl_pause Description: Pauses the main processor. Parameters: None. Response: Success: Pause status. Error: Error message if pausing fails. /tl_getAllBalancesForAddress Description: Retrieves all balances for a specific address. Parameters: params (string) - The address to query. Response: Success: Balances for the address. Error: Error message if retrieval fails. /tl_getChannel Description: Retrieves channel information for a given address. Parameters: params (string) - The address to query. Response: Success: Channel information or message if no channel is found. Error: Error message if retrieval fails. Example Response: ```json {\"_id\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\",\"data\":{\"participants\":{\"A\":\"\",\"B\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\"},\"channel\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\",\"commits\":[{\"senderAddress\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\",\"propertyId\":4,\"tokenAmount\":0.00001,\"block\":3348377,\"columnAssigned\":\"B\"},{\"senderAddress\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\",\"propertyId\":4,\"tokenAmount\":0.00001,\"block\":3348528,\"columnAssigned\":\"B\"}],\"A\":{},\"B\":{\"4\":0},\"lastCommitmentTime\":3348528,\"lastUsedColumn\":\"B\"}} --- ### `/tl_createrawtx_opreturn` **Description:** Adds an OP_RETURN to a transaction blob. - **Parameters:** - `txHex` (string) - Transaction hex. - `payload` (string) - OP_RETURN payload. - **Response:** - Success: Transaction with OP_RETURN added. - Error: Error message if creation fails. --- ### `/tl_getProperty` **Description:** Retrieves property data based on property ID. - **Parameters:** - `params` (string) - Property ID. - **Response:** - Success: Property data. - Error: Error message if retrieval fails. **Example Response:** ```json [1,{\\\"ticker\\\":\\\"TL\\\",\\\"totalInCirculation\\\":500000,\\\"type\\\":1,\\\"whitelistId\\\":0}] /tl_listProperties Description: Lists all properties. Parameters: None. Response: Success: Array of properties. Error: Error message if retrieval fails. Example Response: ```json {\"_id\":\"propertyIndex\",\"value\":\"[[1,{\\\"ticker\\\":\\\"TL\\\",\\\"totalInCirculation\\\":500000,\\\"type\\\":1,\\\"whitelistId\\\":0}],[2,{\\\"ticker\\\":\\\"TLVEST\\\",\\\"totalInCirculation\\\":250000,\\\"type\\\":4,\\\"whitelistId\\\":0}],[3,{\\\"ticker\\\":\\\"TLIVEST\\\",\\\"totalInCirculation\\\":1500000,\\\"type\\\":4,\\\"whitelistId\\\":0}],[4,{\\\"ticker\\\":\\\"TLI\\\",\\\"totalInCirculation\\\":1500001,\\\"type\\\":3,\\\"whitelistId\\\":0}],[5,{\\\"ticker\\\":\\\"TJRZT\\\",\\\"totalInCirculation\\\":694258,\\\"type\\\":1,\\\"whitelistId\\\":0,\\\"issuer\\\":\\\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\\\",\\\"backupAddress\\\":\\\"LNmiS6p8z3KuHHx3q6Jf6x6TfcyptE68oP\\\"}],[6,{\\\"ticker\\\":\\\"CELFE\\\",\\\"totalInCirculation\\\":741256,\\\"type\\\":1,\\\"whitelistId\\\":0,\\\"issuer\\\":\\\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\\\",\\\"backupAddress\\\":\\\"LNmiS6p8z3KuHHx3q6Jf6x6TfcyptE68oP\\\"}],[7,{\\\"ticker\\\":\\\"OZGJE\\\",\\\"totalInCirculation\\\":471902,\\\"type\\\":1,\\\"whitelistId\\\":0,\\\"issuer\\\":\\\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\\\",\\\"backupAddress\\\":\\\"LNmiS6p8z3KuHHx3q6Jf6x6TfcyptE68oP\\\"}]]\"} --- ### `/tl_listFeeCache` **Description:** Retrieves fee cache for all properties. - **Parameters:** None. - **Response:** - Success: Fee cache data. - Error: Error message if retrieval fails. **Example Response:** ```json {id:’feeCache’, value:[{id:1, amount:123432.2343},{id:5,amount: 343.23}] /tl_propertyFeeCache Description: Retrieves fee cache for a specific property. Parameters: id (string) - Property ID. Response: Success: Fee cache data for the property. Error: Error message if retrieval fails. Example Response: ```json {id:5,amount: 343.23} --- ### `/tl_getActivations` **Description:** Retrieves the list of activations. - **Parameters:** None. - **Response:** - Success: Array of activations. - Error: Error message if retrieval fails. --- ### `/tl_getOrderbook` **Description:** Retrieves the order book for a given property pair. - **Parameters:** - `propertyId1` (number) - First property ID. - `propertyId2` (number) - Second property ID. - **Response:** - Success: Order book data. - Error: Error message if retrieval fails. --- ### `/tl_getContractOrderbook` **Description:** Retrieves the contract order book. - **Parameters:** - `contractId` (number) - Contract ID. - **Response:** - Success: Contract order book data. - Error: Error message if retrieval fails. --- ### `/tl_listContractSeries` **Description:** Lists series for a specific contract. - **Parameters:** - `contractId` (number) - Contract ID. - **Response:** - Success: Array of contract series. - Error: Error message if retrieval fails. **Example Response:** ```json {\"id\":1,\"data\":{\"id\":1,\"issuer\":\"tltc1qa0kd2d39nmeph3hvcx8ytv65ztcywg5sazhtw8\",\"native\":true,\"underlyingOracleId\":0,\"onChainData\":[[0,1]],\"notionalPropertyId\":0,\"notionalValue\":0.0001,\"collateralPropertyId\":1,\"leverage\":5,\"expiryPeriod\":4032,\"series\":5,\"inverse\":true,\"fee\":false,\"whitelist\":0,\"contracts\":{\"expired\":[],\"unexpired\":[{\"id\":\"1-3086534\",\"expirationBlock\":3086534},{\"id\":\"1-3090566\",\"expirationBlock\":3090566},{\"id\":\"1-3094598\",\"expirationBlock\":3094598},{\"id\":\"1-3098630\",\"expirationBlock\":3098630},{\"id\":\"1-3102662\",\"expirationBlock\":3102662}]},\"ammPool\":{\"position\":0,\"maxPosition\":1,\"maxQuoteSize\":10,\"contractType\":1,\"lpAddresses\":{},\"ammOrders\":[]}},\"type\":\"contractSeries\",\"_id\":\"c3ChX43pOXVagVqn\"} /tl_listOracles Description: Lists all oracles. Parameters: None. Response: Success: Array of oracles. Error: Error message if retrieval fails. /tl_listClearlists Description: Lists all clearLists. Parameters: None. Response: Success: Array of clearlists. Error: Error message if retrieval fails. Example Response: ```json {\"_id\":1,\"data\":{\"name\":\"Market Maker Whitelist\",\"description\":\"Market Makers and active traders who do not wash trade.\"}} — ### `/tl_showClearlist` **Description:** Lists all clearLists. - **Parameters:** id - **Response:** - Success: Array of clearlists. - Error: Error message if retrieval fails. **Example Response:** ```json {\"_id\":1,\"data\":{\"name\":\"Market Maker Whitelist\",\"description\":\"Market Makers and active traders who do not wash trade.\"}} — /tl_contractPosition Description: Retrieves the contract position for a given address and contract ID. Parameters: address (string) - Address to query. contractId (number) - Contract ID. Response: Success: Contract position data. Error: Error message if retrieval fails. /tl_tradeHistory Description: Retrieves the trade history for a given property pair. Parameters: propertyId1 (number) - First property ID. propertyId2 (number) - Second property ID. Response: Success: Trade history data. Error: Error message if retrieval fails. Example Response: ```json {\"_id\":\"token-1-0-cbd88a9b-e324-458d-ada8-26be4c57becf-3395569\",\"key\":\"token-1-0\",\"type\":\"token\",\"trade\":{\"offeredPropertyId\":1,\"desiredPropertyId\":0,\"amountOffered\":1e-8,\"amountExpected\":1000000},\"blockHeight\":3395569,\"txid\":\"c59fd0a35bc93979133cda1ae86c235428112c153fbdabed2cbc7ea86e60543f\"} ``` /tl_getInitMargin Description: Retrieves the initial margin for a contract based on price. Parameters: contractId (number) - Contract ID. price (number) - Price of the contract. Response: Success: Returns a number for the amount of collateral id needed at the given price to margin 1 contract.. Error: Error message if retrieval fails. /tl_contractTradeHistory Description: Retrieves trade history for a specific contract. Parameters: contractId (number) - Contract ID. Response: Success: Contract trade history data. Error: Error message if retrieval fails. /tl_fundingHistory Description: Retrieves funding history for a specific contract. Parameters: contractId (number) - Contract ID. Response: Success: Funding history data. Error: Error message if retrieval fails. /tl_oracleHistory Description: Retrieves oracle history for a specific contract. Parameters: contractId (number) - Contract ID. Response: Success: Oracle history data. Error: Error message if retrieval fails. "}}